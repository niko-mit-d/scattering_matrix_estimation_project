
% For questions regarding the code contact: 
% Ben Schittenkopf (e11901911@student.tuwien.ac.at)

% General notes:
% 1)When we write domn matices as column vectors, we do the ordering
% along the rows. Example:
%
%                   a_1
% a_1 a_2   =>      a_2
% a_3 a_4           a_3
%                   a_4
%
%
% 2)The K_I and K_II from my thesis are not the same K_I and K_II here in the
% code. Here in the code K_I and K_II are equivalent to A_I and A_II in the
% thesis.

dim = 2;
del_t = 0.01;
number_of_matrices = 500;
noise_factor = 0.01;
h_sqr = [];
are_error_sqr = [];
aim_error_sqr = [];

Vector_array = [];
list_for_plot = [];
statistics_of_noise_real = zeros(dim^2);
statistics_of_noise_imag = zeros(dim^2);

are = randn(dim);
aim = randn(dim);
S_start = are + 1i*aim;
S_inter = S_start;

%% Statistics of noise

% Here I attempted to make a analysis of the white noise generated by the randn() function.
% I did not check if it makes the performance of the observer better or worse,
% compared to the fixed-paramater-approach for the R,G and Q matrices.

for w = 1:100
    rand_vec_real = noise_factor*randn(dim^2,1);
    rand_vec_imag = noise_factor*randn(dim^2,1);

    statistics_of_noise_real = statistics_of_noise_real + kron(rand_vec_real,rand_vec_real.');
    statistics_of_noise_imag = statistics_of_noise_imag + kron(rand_vec_imag,rand_vec_imag.');
end

statistics_of_noise_real = statistics_of_noise_real/w;
statistics_of_noise_imag = statistics_of_noise_imag/w;

%% Jacobians

% Jacobian of the constraints. Taken from corresponding Mathematica file.

JacobRe=[2.*are(1,1),0,2.*are(2,1),0;are(1,2),are(1,1),are(2,2),are(2,1);(-1).* ...
    aim(1,2),aim(1,1),(-1).*aim(2,2),aim(2,1);0,2.*are(1,2),0,2.*are(2,2)];
    
JacobIm=[2.*aim(1,1),0,2.*aim(2,1),0;aim(1,2),aim(1,1),aim(2,2),aim(2,1);are(1, ...
    2),(-1).*are(1,1),are(2,2),(-1).*are(2,1);0,2.*aim(1,2),0,2.*aim(2,2)];
    
% Second Jacobian of the constraints. Taken from corresponding Mathematica file.

JacobRe2=[[2,0,0,0;0,0,0,0;0,0,2,0;0,0,0,0],[0,1,0,0;1,0,0,0;0,0,0,1;0,0,1,0],[0, ...
    0,0,0;0,0,0,0;0,0,0,0;0,0,0,0],[0,0,0,0;0,2,0,0;0,0,0,0;0,0,0,2]];

        JacobIm2=[[2,0,0,0;0,0,0,0;0,0,2,0;0,0,0,0],[0,1,0,0;1,0,0,0;0,0,0,1;0,0,1,0],[0, ...
    0,0,0;0,0,0,0;0,0,0,0;0,0,0,0],[0,0,0,0;0,2,0,0;0,0,0,0;0,0,0,2]];

% In the Mathematica file the second Jacobian is a dim^2 x dim^2 x dim2 tensor,
% but in the export to Matlab one gets a dim^2 x (dim^2)^2 matrix.
% The code below is supposed to transform the matrix into the dim^2 x dim^2 x dim2 tensor.

JacobRe3 = zeros(dim^2,dim^2,dim^2);
for t1 = 1:dim^2
   for t2 = 1:dim^2
       JacobRe3(t1,t2,:) = JacobRe2(t1,1+(t2-1)*dim^2:dim^2+(t2-1)*dim^2);
   end
end
        
JacobIm3 = zeros(dim^2,dim^2,dim^2);
for t1 = 1:dim^2
   for t2 = 1:dim^2
        JacobIm3(t1,t2,:) = JacobIm2(t1,1+(t2-1)*dim^2:dim^2+(t2-1)*dim^2);
   end
end


%% Create scattering matrix random walk

for t = 1:number_of_matrices

    are2 = randn(dim);
    aim2 = randn(dim);

    S = are2 + 1i*aim2;

    S_vec = matrix_to_vec(S,dim);                   % The matrices have to be converted into vectors in order for movmean() to work.

    Vector_array = [Vector_array, S_vec];
    
end

Means = movmean(Vector_array,20,2);                 % Creates averged vectors (matrices) over 20 matrices from Vector_array. The 2 indicates that it calculates the averages along the rows.

for w2 = 1:number_of_matrices                       % This makes all matrices in Means unitary.
    mat_from_Means = vec_to_matrix(Means(:,w2),dim);
    mat_from_Means = gson(mat_from_Means);
    Means(:,w2) = matrix_to_vec(mat_from_Means,dim);
end


%% Observer


k_I = 1e-4;                 
k_II = 1e-4;                
K_I = k_I*eye(dim^2);
K_II = k_II*eye(dim^2);




for time = 1:number_of_matrices

    display(time)
    for i = 0:30                    % Number of measurments before we proceede to the next matrix in the matrix random walk 
        
        S_inter_vec_real = reals_or_imags_from_matrix_to_vec(S_inter,1,dim);
        S_inter_vec_imag = reals_or_imags_from_matrix_to_vec(S_inter,2,dim);

        
        % The follwing lines are supposed to pick a column of the end scattering matrix for the measurment. If one sets k = 1 in
        % mod(j,k), after every time step another column gets picked. It will move trough the the columns in their order
        % i.e. starting with the first, moving to the second etc.
        % If one sets k for example equal to 10, then 10 measurments of one column will be performed until the column is changed.

        if i == 0
            j = 1;
            n = 1;
        elseif mod(j,10) == 0
            if n+1 > dim
                n = 1;
                j = 1;    
            else
               n = n+1;
                j = 1; 
            end
        else
            j = j+1;
        end

        


        % Implementing constraints

        real_constr = mixedconstr(are,aim);

         
        % Measurement

        noise = noise_factor*(randn(dim,1)+1i*randn(dim,1));

        current_matrix_of_Means = vec_to_matrix(squeeze(Means(:,time)),dim);

        if i == 0
        meas = current_matrix_of_Means(:,n);
        else
        meas = current_matrix_of_Means(:,n)+noise;
        end

        S_end_vec_real = reals_or_imags_from_matrix_to_vec(current_matrix_of_Means,1,dim);
        S_end_vec_imag = reals_or_imags_from_matrix_to_vec(current_matrix_of_Means,2,dim);


        old_col = S_inter(:,n);
        diff_y_real = real(meas-old_col);
        diff_y_imag = imag(meas-old_col);
        diff_y_real = conv_real_of_col_to_big_vec(diff_y_real,n,dim);
        diff_y_imag = conv_real_of_col_to_big_vec(diff_y_imag,n,dim);







        % Kalman-Filter
        
%         r_real = 0.0001;            
%         r_imag = 0.0001;
        g_real = 0.0001;            
        g_imag = 0.0001;
        q_real = 0.0001;
        q_imag = 0.0001;
        P_minus_real = tensorprod(diff_y_real,diff_y_real,dim);          
        P_minus_imag = tensorprod(diff_y_imag,diff_y_imag,dim);
        G_real = g_real*eye(dim^2);
        G_imag = g_imag*eye(dim^2);
        R_real = statistics_of_noise_real;         % variance^2 of sensor noise on the diagonals
        R_imag = statistics_of_noise_imag;
        Q_real = q_real*eye(dim^2);         
        Q_imag = q_imag*eye(dim^2);
        

        C = diag(conv_real_of_col_to_big_vec(ones(dim,1),n,dim));
        

        L_real = P_minus_real*C.'/(C*P_minus_real*C.'+R_real);
        P_plus_real = (eye(dim^2)-L_real*C)*P_minus_real;

        % I was not sure anymore, if this update of JacobRe here is
        % necessary or not. I don't think so but anyways, I left it here for now.

        JacobRe=[2.*are(1,1),0,2.*are(2,1),0;are(1,2),are(1,1),are(2,2),are(2,1);(-1).* ...
            aim(1,2),aim(1,1),(-1).*aim(2,2),aim(2,1);0,2.*are(1,2),0,2.*are(2,2)];

        JJhIm1 = einsum(inv(JacobRe),JacobRe3,'ij,ikh->jkh');
        JJhIm2 = -einsum(JJhIm1,inv(JacobRe),'jkh,ki->jih');
        JJhIm3 = einsum(JJhIm2,K_I,'jih,jq->qih');
        JJhIm4 = einsum(JJhIm3,real_constr,'qih,qb->bih');
        JJhIm4 = squeeze(JJhIm4);

        % After the first JJhIm4 line JJIm4 is still a tensor, where of
        % dimesnion dim x dim x 0, the zero at the end makes problems,
        % therefore is the squeeze()-function, which get's rid of the
        % superfluose dimension.

        Phi_re = eye(dim^2) - del_t*(JJhIm4+JacobRe\K_I*JacobRe);

        S_inter_vec_real = S_inter_vec_real + L_real*diff_y_real;
        S_inter_vec_real = S_inter_vec_real-del_t*(JacobRe\K_I*real_constr);
        
        P_minus_real = Phi_re*P_plus_real*Phi_re.' + G_real*Q_real*G_real.';


     

        
        L_imag = P_minus_imag*C.'/(C*P_minus_imag*C.'+R_imag);
        P_plus_imag = (eye(dim^2)-L_imag*C)*P_minus_imag;

        % Same for JacobIm

        JacobIm=[2.*aim(1,1),0,2.*aim(2,1),0;aim(1,2),aim(1,1),aim(2,2),aim(2,1);are(1, ...
            2),(-1).*are(1,1),are(2,2),(-1).*are(2,1);0,2.*aim(1,2),0,2.*aim(2,2)];

        JJhIm1 = einsum(inv(JacobIm),JacobIm3,'ij,ikh->jkh');
        JJhIm2 = -einsum(JJhIm1,inv(JacobIm),'jkh,ki->jih');
        JJhIm3 = einsum(JJhIm2,K_II,'jih,jq->qih');
        JJhIm4 = einsum(JJhIm3,real_constr,'qih,qb->bih');
        JJhIm4 = squeeze(JJhIm4);

        Phi_im = eye(dim^2) - del_t*(JJhIm4+JacobIm\K_I*JacobIm);

        S_inter_vec_imag = S_inter_vec_imag + L_imag*diff_y_imag;
        S_inter_vec_imag = S_inter_vec_imag-del_t*(JacobIm\K_II*real_constr); 
        
        P_minus_imag = Phi_im*P_plus_imag*Phi_im.' + G_imag*Q_imag*G_imag.';






        are = real_vec_to_matrix(S_inter_vec_real,dim);
        aim = real_vec_to_matrix(S_inter_vec_imag,dim);

        S_inter = are + 1i*aim;


        h_sqr = [h_sqr; transpose(real_constr)*real_constr];
        are_error_sqr = [are_error_sqr; transpose(S_end_vec_real-S_inter_vec_real)*(S_end_vec_real-S_inter_vec_real)];
        aim_error_sqr = [aim_error_sqr; transpose(S_end_vec_imag-S_inter_vec_imag)*(S_end_vec_imag-S_inter_vec_imag)];

    end

    


end



%% plotting
% for plotting in Matlab
% figure(1)
% plot(linspace(0,length(are_error_sqr),length(are_error_sqr)),are_error_sqr);
% 
% figure(2)
% plot(linspace(0,length(aim_error_sqr),length(aim_error_sqr)),aim_error_sqr);
% 
% figure(3)
% plot(linspace(0,length(h_sqr),length(h_sqr)),h_sqr);



dlmwrite("h_sqr_rand_walk_test.csv",h_sqr);
dlmwrite("are_error_sqr_rand_walk_test.csv",are_error_sqr);
dlmwrite("aim_error_sqr_rand_walk_test.csv",aim_error_sqr);




%% functions
   
function M = real_vec_to_matrix(vec,dim)                        % converts a dim^2 cd
    M = zeros(dim);
    vec2 = [];
    for i = 0:dim-1
        vec2 = vec(1+i*dim:dim+i*dim);
        M(i+1,:) = vec2;
    end
    vec2 = vec2.';
end

function vec2 = conv_real_of_col_to_big_vec(vec,n,dim)          % Converts the nth column of a matrix into the vector form which was introduced at the beginning of the file.
    vec2 = zeros(dim*dim,1);
    for i = 0:dim-1
        vec2(n+i*dim) = vec(i+1);
    end
end
                                                                % In other words, it is assumed that a matrix contains only zeros except the nth column and then this matrix gets cast into the vector form.

function mix = mixedconstr(are,aim)                             % constraints as a function of S (real parts and imaginary parts of S)
    VecConstrMix=[(-1)+aim(1,1).^2+aim(2,1).^2+are(1,1).^2+are(2,1).^2, aim(1,1).*aim(1,2)+aim(2,1).*aim(2,2)+are(1,1).*are(1,2)+are(2,1).*are(2,2), (-1).*aim(1,2).*are(1,1)+aim(1,1).*are(1,2)+(-1).*aim(2,2).*are(2,1)+aim(2,1).*are(2,2), (-1)+aim(1,2).^2+aim(2,2).^2+are(1,2).^2+are(2,2).^2];
    mix = VecConstrMix.';
end
                                                                % If you change the dimension, you have to generate the new constraints in the correspondent Mathematica file. These will exported into a separate
                                                                % Matlab file. From there you have to copy them into this function.

function vec = matrix_to_vec(M,dim)                             % Converts a matrix into a vector, similar to conv_real_of_col_to_big_vec.
    vec = [];
    for i = 1:dim
        for j = 1:dim
            vec = [vec real(M(i,j))];
            vec = [vec imag(M(i,j))];
        end
    end
    vec = vec.';
end
                                                                % But now it also separates real from imaginary parts. Real parts come first, imaginary parts second.

function M = vec_to_matrix(v,dim)                               % Inversion of matrix_to_vec
    M = zeros(dim);

    for n = 0:dim-1
        vec = v(1+n*2*dim:2*dim+n*2*dim);
        vec2 = [];
            for k = 1:dim
                vec2 = [vec2 vec(2*k-1) + 1i*vec(2*k)]; 
            end
        M(n+1,:) = vec2;
    end

end


function [Q, R] = gson(X)                                       % Gram-Schmidt othonormalization
% Gram-Schmidt orthonormalization which produces the same result as [Q,R]=qr(X,0)
% Written by Mo Chen (sth4nth@gmail.com).
[d,n] = size(X);
m = min(d,n);
R = zeros(m,n);
Q = zeros(d,m);
for k = 1:m
    R(1:k-1,k) = Q(:,1:k-1)'*X(:,k);
    v = X(:,k)-Q(:,1:k-1)*R(1:k-1,k);
    R(k,k) = norm(v);
    Q(:,k) = v/R(k,k);
end
R(:,m+1:n) = Q'*X(:,m+1:n);
end


function vec = reals_or_imags_from_matrix_to_vec(M,k,dim)       % converts the real (k=1) or imaginary (k=2) part of a matrix into a vector 
    vec = [];
    if k == 1
        for i=1:dim
            for j=1:dim
                vec = [vec;real(M(i,j))];
            end
        end
    elseif k == 2
        for i=1:dim
            for j=1:dim
                vec = [vec;imag(M(i,j))];
            end
        end
    end
end


function C=einsum(A,B,iA,iB)
% Efficiently calculates tensor contraction in any dimension. It uses
% matlab's matrix multiplication so parallelized and optimized. The
% Einstein summation is inspired by NumPy's syntax, but is not identical. 
%
% Usage: einsum(A,B,s) 
%        einsum(A,B,iA,iB)
%
% Calculates the contraction of A and B which are n-dimensional tensors.
% The contraction is specified either by s, in Einstein notation, or by two
% vectors, iA and iB which list the indices to contract on for each tensor.
%
% Example:
%     A=rand(7,4,5);
%     B=rand(5,7);
% To contract the 1st dimension of A with the 2nd dimension of B, use
%   einsum(A, B, 'ijk,li->jkl') OR einsum(A, B, 1, 2)
% The result will be of size [4,5,5]. 
%
% To contract the 3rd dimension of A with the 1st dimension of B, use
%   einsum(A, B, 'ijk,kl->ijl') OR einsum(A, B, 3, 1)
% The result will be of size [7,4,7]. 
%
% To do both contractions at once, use
%   einsum(A,B,'ijk,ki->j') OR einsum(A, B, [1 3], [2 1])
%
% Using the iA, iB it is not possible to specify the order of dimensions
% in the output, they're just in the same order as the inputm with the
% contracted dimensions omitted.
%
% Author: Yohai Bar-Sinai 

sA=size(A);
sB=size(B);
if nargin==3
    [iA, iB, final_permutation]=parse(iA, sA, sB);
else
    final_permutation=false;
end

if size(iA)~=size(iB)
    error('number of dimensions to contract should be equal')
end
for i=1:length(iA)
    if size(A,iA(i))~=size(B,iB(i))
        error(['cannot contract dimension %d of 1st argument (length=%d)'...
            ' with dimension %d of 2nd argument (length=%d)'],...
            iA(i),size(A,iA(i)),iB(i),size(B,iB(i)))
    end
end
if length(iA)~=length(unique(iA)) || length(iB)~=length(unique(iB))
    error('each dimension should appear only once.')
end

dimsA=setdiff(1:ndims(A),iA);
dimsB=setdiff(1:ndims(B),iB);


A=permute(A, [dimsA iA]);
B=permute(B, [iB dimsB]);

A=reshape(A, [], prod(sA(iA)));
B=reshape(B, prod(sB(iB)), []);

C=A*B;
output_shape=[sA(dimsA),sB(dimsB)];
if length(output_shape)>1
    C=reshape(C,[sA(dimsA),sB(dimsB)]);
    if final_permutation
        C=permute(C,final_permutation);
    end
end
end



function [iA, iB, final_permutation]=parse(s, sA, sB)
msg='argument should be a string of the form ''ijk,kjl->il''';
if ~ischar(s)
    error(msg)
end

%assert that every index appear exactly twice
ss=join(split(s,{',','->'}));
ss=ss{1};
for i=1:length(ss)
    if length(find(ss==ss(i)))~=2
        error(['problem with index %s. '...
               'Each index should appear exactly twice'], ss(i))
    end
end

%split input and output indices
s=split(s,'->');
if length(s)~=2 
    error(msg)
end

%split input indices
in=s{1};
out=s{2};
in=split(in,',');
if length(in)~=2
    error(msg)
end
inA=in{1};
inB=in{2};
if length(inA)~=length(sA)
    error(['''%s'' has %d dimensions while the '...
        'first argument has %d'],inA, length(inA), length(sA))
end
if length(inB)~=length(sB)
    error(['''%s'' has %d dimensions while the '...
        'second argument has %d'],inB, length(inB), length(sB))
end
if length(unique(inA))~=length(inA)
    error('''%s'' has a double index',inA)
end
if length(unique(inB))~=length(inB)
    error('''%s'' has a double index',inB)
end
if length(unique(out))~=length(out)
    error('''%s'' has a double index',out)
end

final_permutation=[];
iA=[];
iB=[];
for i=1:length(inA)
    j=find(inB==inA(i));
    if isempty(j)   % i is an output index
        j=find(out==inA(i));
        final_permutation(end+1)=j;%#ok<AGROW>
    else            % i is contracted
        iA(end+1)=i; %#ok<AGROW>
        iB(end+1)=j; %#ok<AGROW>
    end
end
for i=1:length(inB)
    j=find(inB(i)==out);
    if ~isempty(j)   % i is an output index
        final_permutation(end+1)=j;%#ok<AGROW>
    end
end
[~, final_permutation]=sort(final_permutation);
end